<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VESTA — Live 3D Spatial View</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; color: #e0e0e0; font-family: 'Courier New', monospace; overflow: hidden; }
  #canvas-container { width: 100vw; height: 100vh; }
  canvas { display: block; }

  /* Stats overlay */
  #stats {
    position: fixed; top: 16px; left: 16px;
    background: rgba(10,10,10,0.85); border: 1px solid #333;
    border-radius: 8px; padding: 14px 18px;
    font-size: 13px; line-height: 1.6;
    min-width: 220px; pointer-events: none;
  }
  #stats .title { color: #4fc3f7; font-size: 15px; font-weight: bold; margin-bottom: 6px; }
  #stats .label { color: #888; }
  #stats .value { color: #fff; }
  #stats .warn { color: #ff5252; font-weight: bold; }

  /* Collision alert */
  #collision-alert {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(255, 0, 0, 0.15); border: 2px solid #ff5252;
    border-radius: 12px; padding: 20px 40px;
    font-size: 20px; color: #ff5252; font-weight: bold;
    text-align: center; pointer-events: none;
    opacity: 0; transition: opacity 0.3s;
    text-transform: uppercase; letter-spacing: 2px;
  }
  #collision-alert.active { opacity: 1; }

  /* Legend */
  #legend {
    position: fixed; bottom: 16px; left: 16px;
    background: rgba(10,10,10,0.85); border: 1px solid #333;
    border-radius: 8px; padding: 10px 16px;
    font-size: 12px; pointer-events: none;
  }
  #legend .item { display: inline-block; margin-right: 16px; }
  #legend .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; vertical-align: middle; }

  /* Connection status */
  #connection {
    position: fixed; top: 16px; right: 16px;
    font-size: 12px; padding: 6px 12px;
    border-radius: 4px; pointer-events: none;
  }
  #connection.connected { background: rgba(0,200,0,0.2); color: #4caf50; border: 1px solid #4caf50; }
  #connection.disconnected { background: rgba(255,0,0,0.2); color: #ff5252; border: 1px solid #ff5252; }
</style>
</head>
<body>

<div id="canvas-container"></div>

<div id="stats">
  <div class="title">VESTA Spatial View</div>
  <div><span class="label">Heading: </span><span class="value" id="s-heading">0.0</span></div>
  <div><span class="label">Position: </span><span class="value" id="s-position">0.0, 0.0</span></div>
  <div><span class="label">Speed: </span><span class="value" id="s-speed">0.0</span></div>
  <div><span class="label">Hazards: </span><span class="value" id="s-hazards">0</span></div>
  <div id="s-collision-row" style="display:none"><span class="warn" id="s-collision"></span></div>
</div>

<div id="collision-alert"></div>

<div id="connection" class="disconnected">Disconnected</div>

<div id="legend">
  <span class="item"><span class="dot" style="background:#4fc3f7"></span>Worker</span>
  <span class="item"><span class="dot" style="background:#4caf50"></span>Path</span>
  <span class="item"><span class="dot" style="background:#ffeb3b"></span>Trajectory</span>
  <span class="item"><span class="dot" style="background:#ff5252"></span>Hazard</span>
</div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Socket.IO client -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>

<script>
// ── Scene Setup ──────────────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);
scene.fog = new THREE.Fog(0x0a0a0a, 20, 50);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 8, 8);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

// Lighting
const ambient = new THREE.AmbientLight(0x404040, 0.8);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(5, 10, 5);
scene.add(dirLight);

// ── Ground Grid ──────────────────────────────────────────────────────
const gridHelper = new THREE.GridHelper(40, 40, 0x222222, 0x1a1a1a);
scene.add(gridHelper);

// Ground plane (subtle)
const groundGeo = new THREE.PlaneGeometry(40, 40);
const groundMat = new THREE.MeshBasicMaterial({ color: 0x0d0d0d, transparent: true, opacity: 0.5 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
scene.add(ground);

// ── Worker (blue sphere + heading arrow) ─────────────────────────────
const workerGroup = new THREE.Group();

const workerGeo = new THREE.SphereGeometry(0.15, 16, 16);
const workerMat = new THREE.MeshPhongMaterial({ color: 0x4fc3f7, emissive: 0x1a6d9e });
const workerMesh = new THREE.Mesh(workerGeo, workerMat);
workerMesh.position.y = 0.15;
workerGroup.add(workerMesh);

// Glow ring around worker
const ringGeo = new THREE.RingGeometry(0.2, 0.3, 32);
const ringMat = new THREE.MeshBasicMaterial({ color: 0x4fc3f7, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = -Math.PI / 2;
ring.position.y = 0.02;
workerGroup.add(ring);

// Heading arrow
const arrowDir = new THREE.Vector3(0, 0, -1);
const arrowOrigin = new THREE.Vector3(0, 0.15, 0);
const headingArrow = new THREE.ArrowHelper(arrowDir, arrowOrigin, 0.6, 0x4fc3f7, 0.15, 0.1);
workerGroup.add(headingArrow);

scene.add(workerGroup);

// ── Path Trail (green line) ──────────────────────────────────────────
const MAX_PATH_POINTS = 500;
const pathPositions = new Float32Array(MAX_PATH_POINTS * 3);
const pathGeo = new THREE.BufferGeometry();
pathGeo.setAttribute('position', new THREE.BufferAttribute(pathPositions, 3));
pathGeo.setDrawRange(0, 0);
const pathMat = new THREE.LineBasicMaterial({ color: 0x4caf50, transparent: true, opacity: 0.6 });
const pathLine = new THREE.Line(pathGeo, pathMat);
scene.add(pathLine);

// ── Prediction Line (yellow, dashed) ─────────────────────────────────
const MAX_PRED_POINTS = 20;
const predPositions = new Float32Array(MAX_PRED_POINTS * 3);
const predGeo = new THREE.BufferGeometry();
predGeo.setAttribute('position', new THREE.BufferAttribute(predPositions, 3));
predGeo.setDrawRange(0, 0);
const predMat = new THREE.LineDashedMaterial({ color: 0xffeb3b, transparent: true, opacity: 0.8, dashSize: 0.15, gapSize: 0.1 });
const predLine = new THREE.Line(predGeo, predMat);
scene.add(predLine);

// Prediction cone (semi-transparent yellow)
const coneGeo = new THREE.ConeGeometry(0.3, 1.5, 8, 1, true);
const coneMat = new THREE.MeshBasicMaterial({ color: 0xffeb3b, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
const predCone = new THREE.Mesh(coneGeo, coneMat);
predCone.visible = false;
scene.add(predCone);

// ── Hazard Markers ───────────────────────────────────────────────────
const hazardGroup = new THREE.Group();
scene.add(hazardGroup);
const hazardMeshes = {}; // id -> mesh

const SEVERITY_COLORS = {
  critical: 0xff1744,
  high: 0xff9100,
  medium: 0xffea00,
  low: 0x00e676,
};

function getOrCreateHazard(id, label, severity, x, z) {
  if (hazardMeshes[id]) {
    hazardMeshes[id].position.set(x, 0, z);
    return hazardMeshes[id];
  }

  const color = SEVERITY_COLORS[severity] || 0xff1744;
  const group = new THREE.Group();

  // Cylinder marker
  const cylGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 12);
  const cylMat = new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
  const cyl = new THREE.Mesh(cylGeo, cylMat);
  cyl.position.y = 0.3;
  group.add(cyl);

  // Danger ring on ground
  const dRingGeo = new THREE.RingGeometry(0.3, 0.5, 32);
  const dRingMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
  const dRing = new THREE.Mesh(dRingGeo, dRingMat);
  dRing.rotation.x = -Math.PI / 2;
  dRing.position.y = 0.02;
  group.add(dRing);

  // Pulsing outer ring
  const pulseGeo = new THREE.RingGeometry(0.5, 0.55, 32);
  const pulseMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, side: THREE.DoubleSide });
  const pulseRing = new THREE.Mesh(pulseGeo, pulseMat);
  pulseRing.rotation.x = -Math.PI / 2;
  pulseRing.position.y = 0.02;
  group.add(pulseRing);
  group.userData.pulseRing = pulseRing;
  group.userData.pulseMat = pulseMat;

  group.position.set(x, 0, z);
  group.userData.label = label;
  group.userData.severity = severity;

  hazardGroup.add(group);
  hazardMeshes[id] = group;
  return group;
}

// ── Collision danger lines (red lines from prediction to hazard) ─────
const dangerLines = [];

function clearDangerLines() {
  dangerLines.forEach(l => scene.remove(l));
  dangerLines.length = 0;
}

function addDangerLine(fromX, fromZ, toX, toZ) {
  const geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(fromX, 0.2, fromZ),
    new THREE.Vector3(toX, 0.3, toZ),
  ]);
  const mat = new THREE.LineBasicMaterial({ color: 0xff1744, transparent: true, opacity: 0.8 });
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  dangerLines.push(line);
}

// ── Camera follow ────────────────────────────────────────────────────
let cameraTarget = new THREE.Vector3(0, 0, 0);
let cameraOffset = new THREE.Vector3(0, 8, 8);
let autoFollow = true;

// Mouse orbit controls (basic)
let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let orbitAngle = 0;
let orbitPitch = 0.6;
let orbitDist = 10;

renderer.domElement.addEventListener('mousedown', (e) => {
  isDragging = true;
  prevMouse = { x: e.clientX, y: e.clientY };
  autoFollow = false;
});
renderer.domElement.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  orbitAngle -= dx * 0.005;
  orbitPitch = Math.max(0.1, Math.min(1.4, orbitPitch + dy * 0.005));
  prevMouse = { x: e.clientX, y: e.clientY };
});
renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
renderer.domElement.addEventListener('wheel', (e) => {
  orbitDist = Math.max(3, Math.min(30, orbitDist + e.deltaY * 0.01));
  autoFollow = false;
});

// Double-click to re-center
renderer.domElement.addEventListener('dblclick', () => { autoFollow = true; });

// ── State ────────────────────────────────────────────────────────────
let currentCollisions = [];
let pulseTime = 0;
let lastWorkerPos = { x: 0, z: 0 };

// ── Socket.IO ────────────────────────────────────────────────────────
const socket = io();
const connEl = document.getElementById('connection');

socket.on('connect', () => {
  connEl.textContent = 'Connected';
  connEl.className = 'connected';
});
socket.on('disconnect', () => {
  connEl.textContent = 'Disconnected';
  connEl.className = 'disconnected';
});

socket.on('state_update', (data) => {
  // Worker position (swap Y to Z for Three.js)
  const wx = data.worker.x;
  const wz = -data.worker.y;  // VESTA Y -> Three.js -Z (forward)
  const heading = data.worker.heading;

  workerGroup.position.set(wx, 0, wz);
  workerGroup.rotation.y = -THREE.MathUtils.degToRad(heading);
  lastWorkerPos = { x: wx, z: wz };

  // Camera follow
  if (autoFollow) {
    cameraTarget.set(wx, 0, wz);
  }

  // Path trail
  const path = data.path || [];
  const pathCount = Math.min(path.length, MAX_PATH_POINTS);
  const posAttr = pathGeo.attributes.position;
  for (let i = 0; i < pathCount; i++) {
    posAttr.setXYZ(i, path[i][0], 0.05, -path[i][1]);
  }
  posAttr.needsUpdate = true;
  pathGeo.setDrawRange(0, pathCount);

  // Prediction line
  const pred = data.prediction ? data.prediction.points || [] : [];
  const predCount = Math.min(pred.length + 1, MAX_PRED_POINTS);
  const predAttr = predGeo.attributes.position;
  // Start from worker position
  predAttr.setXYZ(0, wx, 0.15, wz);
  for (let i = 0; i < pred.length && i + 1 < MAX_PRED_POINTS; i++) {
    predAttr.setXYZ(i + 1, pred[i][0], 0.15, -pred[i][1]);
  }
  predAttr.needsUpdate = true;
  predGeo.setDrawRange(0, predCount);
  predLine.computeLineDistances();

  // Prediction cone
  if (pred.length >= 2) {
    const lastPred = pred[pred.length - 1];
    const midX = (wx + lastPred[0]) / 2;
    const midZ = (wz + (-lastPred[1])) / 2;
    const dx = lastPred[0] - wx;
    const dz = -lastPred[1] - wz;
    const dist = Math.sqrt(dx * dx + dz * dz);

    predCone.position.set(midX, 0.1, midZ);
    predCone.scale.set(1, dist / 1.5, 1);
    predCone.rotation.x = 0;
    predCone.rotation.z = Math.atan2(dx, dz);
    predCone.rotation.x = Math.PI / 2;
    predCone.lookAt(lastPred[0], 0.1, -lastPred[1]);
    predCone.visible = true;
  } else {
    predCone.visible = false;
  }

  // Hazards
  const hazards = data.hazards || [];
  // Remove stale hazards
  const activeIds = new Set(hazards.map(h => h.id));
  Object.keys(hazardMeshes).forEach(id => {
    if (!activeIds.has(id)) {
      hazardGroup.remove(hazardMeshes[id]);
      delete hazardMeshes[id];
    }
  });
  // Add/update hazards
  hazards.forEach(h => {
    getOrCreateHazard(h.id, h.label, h.severity, h.x, -h.y);
  });

  // Collision warnings
  clearDangerLines();
  currentCollisions = data.prediction ? data.prediction.collisions || [] : [];
  const alertEl = document.getElementById('collision-alert');
  const collRow = document.getElementById('s-collision-row');
  const collText = document.getElementById('s-collision');

  if (currentCollisions.length > 0) {
    const c = currentCollisions[0];
    alertEl.textContent = `${c.label} in ${c.eta_seconds.toFixed(1)}s`;
    alertEl.classList.add('active');
    collRow.style.display = 'block';
    collText.textContent = `COLLISION: ${c.label} in ${c.eta_seconds.toFixed(1)}s`;

    // Change prediction line to red
    predMat.color.setHex(0xff1744);
    coneMat.color.setHex(0xff1744);
    coneMat.opacity = 0.2;

    // Draw danger lines
    currentCollisions.forEach(col => {
      if (col.hazard_x !== undefined) {
        addDangerLine(wx, wz, col.hazard_x, -col.hazard_y);
      }
    });

    // Pulse hazard markers
    currentCollisions.forEach(col => {
      const mesh = hazardMeshes[col.hazard_id];
      if (mesh && mesh.userData.pulseRing) {
        mesh.userData.pulseRing.scale.set(2, 2, 1);
      }
    });
  } else {
    alertEl.classList.remove('active');
    collRow.style.display = 'none';
    predMat.color.setHex(0xffeb3b);
    coneMat.color.setHex(0xffeb3b);
    coneMat.opacity = 0.1;
  }

  // Stats overlay
  document.getElementById('s-heading').textContent = heading.toFixed(1) + '\u00B0';
  document.getElementById('s-position').textContent = `${wx.toFixed(2)}, ${(-wz).toFixed(2)}`;
  document.getElementById('s-hazards').textContent = hazards.length;

  // Speed (compute from path tail)
  if (path.length >= 2) {
    const p1 = path[path.length - 1];
    const p2 = path[path.length - 2];
    const spd = Math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2) * 30;
    document.getElementById('s-speed').textContent = spd.toFixed(2) + ' u/s';
  }
});

// ── Animation Loop ───────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  pulseTime += 0.03;

  // Pulse hazard rings
  Object.values(hazardMeshes).forEach(group => {
    if (group.userData.pulseRing) {
      const s = 1 + 0.3 * Math.sin(pulseTime * 3);
      group.userData.pulseRing.scale.set(s, s, 1);
      group.userData.pulseMat.opacity = 0.2 + 0.2 * Math.sin(pulseTime * 3);
    }
  });

  // Worker glow pulse
  ring.scale.set(
    1 + 0.1 * Math.sin(pulseTime * 2),
    1 + 0.1 * Math.sin(pulseTime * 2),
    1
  );

  // Camera
  if (autoFollow) {
    // Slowly orbit around the worker
    orbitAngle += 0.002;
  }
  const camX = cameraTarget.x + orbitDist * Math.sin(orbitAngle) * Math.cos(orbitPitch);
  const camY = orbitDist * Math.sin(orbitPitch);
  const camZ = cameraTarget.z + orbitDist * Math.cos(orbitAngle) * Math.cos(orbitPitch);
  camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.05);
  camera.lookAt(cameraTarget);

  renderer.render(scene, camera);
}

animate();

// ── Resize ───────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
